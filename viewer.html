<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Viewer (Fixed 4-Measure Wrap)</title>
    <style>
        /* --- 基本設定 --- */
        html { height: 100%; }
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            /* 横スクロールのみ有効にする */
            overflow-y: hidden; 
            overflow-x: auto;
            height: 100%;
        }

        /* --- ヘッダー --- */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: #222;
            border-bottom: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 9999;
            box-sizing: border-box;
        }
        h1 { font-size: 16px; margin: 0; color: #ddd; }
        .controls { display: flex; gap: 10px; }
        button { background: #444; color: #fff; border: 1px solid #666; padding: 5px 12px; cursor: pointer; border-radius: 4px; font-size: 14px; }
        button:hover { background: #555; }
        a.back-link { color: #88f; text-decoration: none; font-size: 14px; margin-right: 15px;}

        /* --- 譜面コンテナ --- */
        #chart-content {
            /* ヘッダー分空ける */
            padding-top: 60px; 
            /* 左側のBPM表示用余白 */
            padding-left: 80px;
            /* 右側の余白 */
            padding-right: 40px;
            /* 下の余白 */
            padding-bottom: 20px;
            
            height: 100%;
            box-sizing: border-box;
            
            /* カラムを横に並べ、下端を揃える */
            display: inline-flex;
            align-items: flex-end; 
            white-space: nowrap;
        }

        /* 1列（カラム） */
        .column {
            display: inline-block;
            vertical-align: bottom;
            
            /* カラム自体のスタイル */
            border: 2px solid #555;
            background: #000;
            position: relative;
            
            /* 幅固定 (レーン40px*4 + 枠線等) */
            width: 164px; 
            
            /* カラム間の間隔 */
            margin-right: 80px;
            
            /* 高さ: 中身（measure-row）の積み上げに依存するが、
               relative内のabsolute配置のために最低限の高さを確保するか、
               JSで高さを指定する。
               今回は「下から積み上げ」なので、見た目上の高さは中身で決まる。
            */
        }

        /* 小節の行 */
        .measure-row {
            position: absolute;
            left: 0;
            width: 100%;
            box-sizing: border-box;
            border-top: 3px solid #fff; /* 小節線 */
        }

        /* グリッド線 */
        .grid-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0px;
            z-index: 0;
            pointer-events: none;
            border-top-width: 1px;
            border-top-style: solid;
        }
        .grid-4 { border-top-color: #666; }
        .grid-16 { border-top-color: #333; }

        /* 左側のラベル */
        .measure-number {
            position: absolute;
            left: -25px; 
            bottom: 0;
            font-size: 12px;
            color: #aaa;
            text-align: right;
            width: 20px;
            font-weight: bold;
        }
        .bpm-label {
            position: absolute;
            left: -85px; 
            bottom: -5px;
            font-size: 11px;
            color: #0f0; 
            background: rgba(0, 50, 0, 0.8);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            z-index: 10;
            white-space: nowrap;
            text-align: right;
            width: 50px;
        }

        /* レーン */
        .lane-container {
            display: flex;
            height: 100%;
            width: 100%;
        }
        .lane {
            flex: 1; /* 均等割り */
            border-right: 1px solid #333;
            position: relative;
            height: 100%;
        }
        .lane:last-child { border-right: none; }
        
        /* ノーツ */
        .note { position: absolute; left: 0; width: 100%; z-index: 2; }
        .note-1 { background-color: #0ff; box-shadow: 0 0 5px #0ff; }
        .note-2 { background-color: #00BFFF; box-shadow: 0 0 5px #00BFFF; width: 200%; left: 0; z-index: 3; }
        .note-3 { background-color: #00FF7F; box-shadow: 0 0 5px #00FF7F; opacity: 0.9; }
        .note-other { background-color: #aaa; }

    </style>
</head>
<body>

<header>
    <div style="display:flex; align-items:center;">
        <a href="index.html" class="back-link">← 戻る</a>
        <h1 id="chart-title">Loading...</h1>
    </div>
    <div class="controls">
        <button id="btn-scale" onclick="changeScale()">間隔調整 (現在: 310px)</button>
    </div>
</header>

<div id="chart-content"></div>

<script>
    // --- 設定 ---
    const MEASURES_PER_COLUMN = 4; // ★ここを4で固定
    let currentPixelPerMeasure = 310; 
    let loadedRawData = "";

    window.onload = async function() {
        const params = new URLSearchParams(window.location.search);
        const fileName = params.get('file');

        if (!fileName) {
            alert("ファイルが指定されていません");
            return;
        }
        document.getElementById('chart-title').innerText = fileName;

        try {
            const res = await fetch(fileName);
            if (!res.ok) throw new Error("File load error");
            loadedRawData = await res.text();
            renderChart(loadedRawData);
        } catch (e) {
            alert("読み込みエラー: " + e.message);
        }
    };

    function changeScale() {
        const input = prompt("間隔（高さ）調整 (px)\nデフォルト: 310", currentPixelPerMeasure);
        if (input !== null && !isNaN(input) && input > 50) {
            currentPixelPerMeasure = parseInt(input);
            document.getElementById('btn-scale').innerText = `間隔調整 (現在: ${currentPixelPerMeasure}px)`;
            renderChart(loadedRawData);
        }
    }

    function renderChart(rawString) {
        const container = document.getElementById('chart-content');
        container.innerHTML = '';

        const lines = rawString.replace(/\r\n/g, '\n').split('\n');

        // ノーツパース
        const parseLine = (lineStr) => {
            if (!lineStr) return [];
            let clean = lineStr.replace(/,end,".*/, '');
            if(clean.endsWith(',')) clean = clean.slice(0, -1);
            return clean.split(',');
        };

        const fullLanes = [];
        if(lines.length > 10) {
            fullLanes.push(parseLine(lines[3]).concat(parseLine(lines[7])));
            fullLanes.push(parseLine(lines[4]).concat(parseLine(lines[8])));
            fullLanes.push(parseLine(lines[5]).concat(parseLine(lines[9])));
            fullLanes.push(parseLine(lines[6]).concat(parseLine(lines[10])));
        } else {
            console.error("Data too short");
            return;
        }

        let totalMeasures = 0;
        fullLanes.forEach(l => { if(l.length > totalMeasures) totalMeasures = l.length; });

        // --- Phase 1: メタデータ解析 ---
        const metaLines = lines.slice(11);
        const bpmMap = {};
        const divideMap = {};
        
        let defaultDivideLength = 8.0; 
        let state = "BPM"; 

        for (let i = 0; i < metaLines.length; i++) {
            let line = metaLines[i].trim();
            if (line === "") continue;
            if (line === "hideBarLine") break;

            if (state === "BPM") {
                if (line === "divide") {
                    state = "DIVIDE_DEFAULT";
                    continue;
                }
                if (!isNaN(parseFloat(line))) {
                    const mNum = parseInt(line);
                    if (i + 1 < metaLines.length) {
                        const val = parseFloat(metaLines[i+1]);
                        if (!isNaN(val)) {
                            bpmMap[mNum] = val;
                            i++; 
                        }
                    }
                }
            }
            else if (state === "DIVIDE_DEFAULT") {
                const val = parseFloat(line);
                if (!isNaN(val)) {
                    defaultDivideLength = val;
                    if(divideMap[0] === undefined) divideMap[0] = val;
                    state = "DIVIDE_PAIRS";
                }
            }
            else if (state === "DIVIDE_PAIRS") {
                if (!isNaN(parseFloat(line))) {
                    const mNum = parseInt(line);
                    if (i + 1 < metaLines.length) {
                        const val = parseFloat(metaLines[i+1]);
                        if (!isNaN(val)) {
                            divideMap[mNum] = val;
                            i++; 
                        }
                    }
                }
            }
        }

        // --- Phase 2: 小節長(Divide)の確定 ---
        const MEASURE_LENGTHS = [];
        let currentLen = defaultDivideLength;
        if (divideMap[0] !== undefined) currentLen = divideMap[0];

        for (let m = 0; m < totalMeasures; m++) {
            if (divideMap[m] !== undefined) {
                currentLen = divideMap[m];
            }
            MEASURE_LENGTHS[m] = currentLen;
        }

        // --- Phase 3: 描画 ---
        let currentBpmVal = bpmMap[0] || 120;
        
        let currentColumnDiv = null;
        let currentBottomY = 0; // カラム内での積み上げY座標

        for (let m = 0; m < totalMeasures; m++) {
            // ★ 4小節ごとに新しいカラムを作る
            if (m % MEASURES_PER_COLUMN === 0) {
                currentColumnDiv = document.createElement('div');
                currentColumnDiv.className = 'column';
                
                // カラムの高さを明示的に計算（これがないとabsolute配置の親として高さが0になる場合がある）
                // 4小節分の高さを合算して style.height に設定する
                let colHeight = 0;
                for(let k=0; k<MEASURES_PER_COLUMN; k++) {
                    let targetM = m + k;
                    if(targetM < totalMeasures) {
                        colHeight += (MEASURE_LENGTHS[targetM] / 8.0) * currentPixelPerMeasure;
                    }
                }
                currentColumnDiv.style.height = `${colHeight}px`;

                container.appendChild(currentColumnDiv);
                currentBottomY = 0; // リセット
            }

            // BPM更新
            let bpmChanged = false;
            if (bpmMap[m] !== undefined) {
                currentBpmVal = bpmMap[m];
                bpmChanged = true;
            }

            // 高さ計算
            const length = MEASURE_LENGTHS[m];
            const measureHeight = (length / 8.0) * currentPixelPerMeasure;
            
            // 行の作成
            const rowDiv = document.createElement('div');
            rowDiv.className = 'measure-row';
            rowDiv.style.height = `${measureHeight}px`;
            rowDiv.style.bottom = `${currentBottomY}px`; // 下から積み上げる
            
            currentBottomY += measureHeight; // 次の小節のために高さを足す

            // グリッド
            const gridCount = (length / 8.0) * 16; 
            for (let g = 1; g < gridCount; g++) {
                const gridLine = document.createElement('div');
                gridLine.className = 'grid-line';
                gridLine.style.bottom = `${(g / gridCount) * 100}%`;
                if (g % 4 === 0) gridLine.classList.add('grid-4'); 
                else gridLine.classList.add('grid-16'); 
                rowDiv.appendChild(gridLine);
            }

            // 小節番号
            const numSpan = document.createElement('span');
            numSpan.className = 'measure-number';
            numSpan.innerText = m;
            rowDiv.appendChild(numSpan);
            
            // BPMラベル
            if (bpmChanged || m === 0) {
                const bpmSpan = document.createElement('span');
                bpmSpan.className = 'bpm-label';
                bpmSpan.innerText = `BPM ${currentBpmVal}`;
                rowDiv.appendChild(bpmSpan);
            }

            // ノーツ描画 (レーンコンテナを作る)
            const laneContainer = document.createElement('div');
            laneContainer.className = 'lane-container';

            fullLanes.forEach(laneData => {
                const laneDiv = document.createElement('div');
                laneDiv.className = 'lane';
                
                if (m < laneData.length) {
                    const notesStr = laneData[m]; 
                    if (notesStr && notesStr.length > 0) {
                        const totalSteps = notesStr.length;
                        const stepPercent = 100 / totalSteps;

                        for (let i = 0; i < totalSteps; i++) {
                            const char = notesStr[i];
                            if (char !== '0') {
                                const note = document.createElement('div');
                                note.classList.add('note');
                                note.classList.add(`note-${char}`);
                                if (!['1','2','3'].includes(char)) note.classList.add('note-other');

                                if (char === '3') {
                                    note.style.height = `${stepPercent * 3}%`;
                                    note.style.bottom = `${(i - 1) * stepPercent}%`;
                                } else {
                                    note.style.height = '6px';
                                    note.style.bottom = `${i * stepPercent}%`;
                                }
                                laneDiv.appendChild(note);
                            }
                        }
                    }
                }
                laneContainer.appendChild(laneDiv);
            });
            rowDiv.appendChild(laneContainer);
            
            // カラムに追加
            currentColumnDiv.appendChild(rowDiv);
        }
    }
</script>
</body>
</html>
