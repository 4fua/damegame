<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chart Viewer (Mobile Fixed)</title>
    <style>
        /* --- 基本設定 --- */
        html {
            /* 高さを固定しない */
            height: auto;
            min-height: 100%;
        }

        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            
            /* ★重要: 縦横どちらもスクロールを許可する */
            overflow: auto; 
            
            /* 中身が少なくても画面いっぱいまで黒くする */
            min-height: 100vh;
            width: 100%;
        }

        /* --- ヘッダー --- */
        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: #222;
            border-bottom: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 9999;
            box-sizing: border-box;
        }
        h1 { font-size: 16px; margin: 0; color: #ddd; }
        .controls { display: flex; gap: 30px; }
        button { background: #444; color: #fff; border: 1px solid #666; padding: 5px 12px; cursor: pointer; border-radius: 4px; font-size: 14px; }
        button:hover { background: #555; }
        a.back-link { color: #88f; text-decoration: none; font-size: 14px; margin-right: 15px;}

        /* --- 譜面コンテナ --- */
        #chart-scroll-area {
            /* 画面固定(height:100%)をやめ、中身なりに伸ばす */
            width: 100%;
            height: auto; 
            
            padding-top: 50px; /* ヘッダー分 */
            box-sizing: border-box;
        }

        #chart-content {
            /* コンテンツ自体も高さを固定しない */
            height: auto;
            min-height: calc(100vh - 50px); /* 最低でも画面の高さは確保 */
            
            /* 余白調整 */
            padding: 40px 40px 20px 80px; 
            box-sizing: border-box;
            
            display: inline-flex;
            align-items: flex-end; /* 下揃え */
        }

        /* 1列（カラム） */
        .column {
            display: inline-flex;
            flex-direction: column-reverse; /* 下から上へ */
            vertical-align: bottom;
            
            border: 2px solid #555;
            background: #000;
            flex-shrink: 0;
            position: relative;
            margin-right: 100px; /* カラム間の間隔 */
        }

        /* 小節の行 */
        .measure-row {
            display: flex;
            width: 100%;
            position: relative;
            box-sizing: border-box;
            flex-shrink: 0; 
            border-top: 3px solid #fff; 
        }

        /* グリッド線 */
        .grid-line {
            position: absolute; left: 0; width: 100%; height: 0px; z-index: 0; pointer-events: none;
            border-top-width: 1px; border-top-style: solid;
        }
        .grid-4 { border-top-color: #666; }
        .grid-16 { border-top-color: #333; }

        /* 左側のラベル */
        .measure-number {
            position: absolute; left: -25px; bottom: 0;
            font-size: 12px; color: #aaa; text-align: right; width: 20px; font-weight: bold;
        }
        .bpm-label {
            position: absolute; left: -85px; bottom: -5px;
            font-size: 11px; color: #0f0; background: rgba(0, 50, 0, 0.8);
            padding: 2px 4px; border-radius: 3px; font-weight: bold;
            z-index: 10; white-space: nowrap; text-align: right; width: 50px;
        }

        /* レーン */
        .lane {
            width: 40px; border-right: 1px solid #333; position: relative; height: 100%;
        }
        .lane:last-child { border-right: none; }
        
        /* ノーツ */
        .note { position: absolute; left: 0; width: 100%; z-index: 2; }
        .note-1 { background-color: #0ff; box-shadow: 0 0 5px #0ff; }
        .note-2 { background-color: #00BFFF; box-shadow: 0 0 5px #00BFFF; width: 200%; left: 0; z-index: 3; }
        .note-3 { background-color: #00FF7F; box-shadow: 0 0 5px #00FF7F; opacity: 0.9; }
        .note-other { background-color: #aaa; }

    </style>
</head>
<body>

<header>
    <div style="display:flex; align-items:center;">
        <a href="index.html" class="back-link">← 戻る</a>
        <h1 id="chart-title">Loading...</h1>
    </div>
    <div class="controls">
        <button id="btn-scale" onclick="changeScale()">間隔調整 (現在: 310px)</button>
    </div>
</header>

<div id="chart-scroll-area">
    <div id="chart-content"></div>
</div>

<script>
    // --- 設定 ---
    const MEASURES_PER_COLUMN = 4; // 4小節ごとに右へ折り返し
    let currentPixelPerMeasure = 350; // デフォルト高さ
    let loadedRawData = "";

    window.onload = async function() {
        const params = new URLSearchParams(window.location.search);
        const fileName = params.get('file');

        if (!fileName) {
            alert("ファイルが指定されていません");
            return;
        }
        document.getElementById('chart-title').innerText = fileName;

        try {
            const res = await fetch(fileName);
            if (!res.ok) throw new Error("File load error");
            loadedRawData = await res.text();
            renderChart(loadedRawData);
        } catch (e) {
            alert("読み込みエラー: " + e.message);
        }
    };

    function changeScale() {
        const input = prompt("間隔（高さ）調整 (px)\nデフォルト: 310", currentPixelPerMeasure);
        if (input !== null && !isNaN(input) && input > 50) {
            currentPixelPerMeasure = parseInt(input);
            document.getElementById('btn-scale').innerText = `間隔調整 (現在: ${currentPixelPerMeasure}px)`;
            renderChart(loadedRawData);
        }
    }

    function renderChart(rawString) {
        const container = document.getElementById('chart-content');
        container.innerHTML = '';

        const lines = rawString.replace(/\r\n/g, '\n').split('\n');

        // ノーツパース (空白小節を維持)
        const parseLine = (lineStr) => {
            if (!lineStr) return [];
            let clean = lineStr.replace(/,end,".*/, '');
            if(clean.endsWith(',')) clean = clean.slice(0, -1);
            return clean.split(',');
        };

        const fullLanes = [];
        if(lines.length > 10) {
            fullLanes.push(parseLine(lines[3]).concat(parseLine(lines[7])));
            fullLanes.push(parseLine(lines[4]).concat(parseLine(lines[8])));
            fullLanes.push(parseLine(lines[5]).concat(parseLine(lines[9])));
            fullLanes.push(parseLine(lines[6]).concat(parseLine(lines[10])));
        }

        let totalMeasures = 0;
        fullLanes.forEach(l => { if(l.length > totalMeasures) totalMeasures = l.length; });

        // --- Phase 1: メタデータ解析 ---
        const metaLines = lines.slice(11);
        const bpmMap = {};
        const divideMap = {};
        
        let defaultDivideLength = 8.0; 
        let state = "BPM"; 

        for (let i = 0; i < metaLines.length; i++) {
            let line = metaLines[i].trim();
            if (line === "") continue;
            if (line === "hideBarLine") break;

            if (state === "BPM") {
                if (line === "divide") {
                    state = "DIVIDE_DEFAULT";
                    continue;
                }
                if (!isNaN(parseFloat(line))) {
                    const mNum = parseInt(line);
                    if (i + 1 < metaLines.length) {
                        const val = parseFloat(metaLines[i+1]);
                        if (!isNaN(val)) {
                            bpmMap[mNum] = val;
                            i++; 
                        }
                    }
                }
            }
            else if (state === "DIVIDE_DEFAULT") {
                const val = parseFloat(line);
                if (!isNaN(val)) {
                    defaultDivideLength = val;
                    if(divideMap[0] === undefined) divideMap[0] = val;
                    state = "DIVIDE_PAIRS";
                }
            }
            else if (state === "DIVIDE_PAIRS") {
                if (!isNaN(parseFloat(line))) {
                    const mNum = parseInt(line);
                    if (i + 1 < metaLines.length) {
                        const val = parseFloat(metaLines[i+1]);
                        if (!isNaN(val)) {
                            divideMap[mNum] = val;
                            i++; 
                        }
                    }
                }
            }
        }

        // --- Phase 2: 小節長(Divide)の確定 ---
        const MEASURE_LENGTHS = [];
        let currentLen = defaultDivideLength;
        if (divideMap[0] !== undefined) currentLen = divideMap[0];

        for (let m = 0; m < totalMeasures; m++) {
            if (divideMap[m] !== undefined) {
                currentLen = divideMap[m];
            }
            MEASURE_LENGTHS[m] = currentLen;
        }

        // --- Phase 3: 描画 ---
        let currentBpmVal = bpmMap[0] || 120;
        let currentColumnDiv = null;

        for (let m = 0; m < totalMeasures; m++) {
            if (m % MEASURES_PER_COLUMN === 0) {
                currentColumnDiv = document.createElement('div');
                currentColumnDiv.className = 'column';
                container.appendChild(currentColumnDiv);
            }

            // BPM更新
            let bpmChanged = false;
            if (bpmMap[m] !== undefined) {
                currentBpmVal = bpmMap[m];
                bpmChanged = true;
            }

            // 高さ計算: (Divide / 8.0) * Scale
            const length = MEASURE_LENGTHS[m];
            const measureHeight = (length / 8.0) * currentPixelPerMeasure;
            
            const rowDiv = document.createElement('div');
            rowDiv.className = 'measure-row';
            rowDiv.style.height = `${measureHeight}px`;

            // グリッド (16分音符)
            const gridCount = (length / 8.0) * 16; 
            for (let g = 1; g < gridCount; g++) {
                const gridLine = document.createElement('div');
                gridLine.className = 'grid-line';
                gridLine.style.bottom = `${(g / gridCount) * 100}%`;
                if (g % 4 === 0) gridLine.classList.add('grid-4'); 
                else gridLine.classList.add('grid-16'); 
                rowDiv.appendChild(gridLine);
            }

            // 小節番号
            const numSpan = document.createElement('span');
            numSpan.className = 'measure-number';
            numSpan.innerText = m;
            rowDiv.appendChild(numSpan);
            
            // BPMラベル
            if (bpmChanged || m === 0) {
                const bpmSpan = document.createElement('span');
                bpmSpan.className = 'bpm-label';
                bpmSpan.innerText = `BPM ${currentBpmVal}`;
                rowDiv.appendChild(bpmSpan);
            }

            // ノーツ
            fullLanes.forEach(laneData => {
                const laneDiv = document.createElement('div');
                laneDiv.className = 'lane';
                
                if (m < laneData.length) {
                    const notesStr = laneData[m]; 
                    if (notesStr && notesStr.length > 0) {
                        const totalSteps = notesStr.length;
                        const stepPercent = 100 / totalSteps;

                        for (let i = 0; i < totalSteps; i++) {
                            const char = notesStr[i];
                            if (char !== '0') {
                                const note = document.createElement('div');
                                note.classList.add('note');
                                note.classList.add(`note-${char}`);
                                if (!['1','2','3'].includes(char)) note.classList.add('note-other');

                                if (char === '3') {
                                    note.style.height = `${stepPercent * 3}%`;
                                    note.style.bottom = `${(i - 1) * stepPercent}%`;
                                } else {
                                    note.style.height = '6px';
                                    note.style.bottom = `${i * stepPercent}%`;
                                }
                                laneDiv.appendChild(note);
                            }
                        }
                    }
                }
                rowDiv.appendChild(laneDiv);
            });

            currentColumnDiv.appendChild(rowDiv);
        }
    }
</script>
</body>
</html>

